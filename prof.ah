#ifndef __PROF_AH__
#define __PROF_AH__

#include <new>
#include <map>
#include <vector>
#include <ctime>
#include <string>
#include <cassert>
#include <iostream>

struct TRunningInfo {
   clock_t fStartTicks;
   unsigned long fReferenceCount;
   unsigned long fCalls;
};

struct TTotalInfo {
   unsigned long fTotalTicks;
   unsigned long fCalls;
   TTotalInfo(unsigned long totalTicks, unsigned long calls) : fTotalTicks(totalTicks), fCalls(calls) { };
};

struct TCallInfo {
   TCallInfo * fParent;
   TCallInfo * fNeighbor;
   std::string fFunction;
   bool fHasChild;
   TCallInfo(TCallInfo * parent, TCallInfo * neighbor, const std::string & function) :
      fParent(parent), fNeighbor(neighbor), fFunction(function), fHasChild(false) {};
};

enum EOutput {
   kStdOut,
   kCallgrind,
   kOutputMax
};

aspect TProfiler {
   pointcut functions() = "% ...::%(...)";
   pointcut mainargs() = "% main(int, char**)";

   advice execution(functions()) : before() {
      clock_t now = clock();
      std::string function = JoinPoint::signature();
      std::map<std::string, TRunningInfo>::iterator desc = fCurrent.find(function);

      if (desc != fCurrent.end()) {
         // Handle recursive calls
         ++(desc->second.fReferenceCount);
         ++(desc->second.fCalls);
      } else {
         TRunningInfo info;
         info.fStartTicks = now;
         info.fReferenceCount = 1;
         info.fCalls = 1;
         fCurrent.insert(desc, std::pair<std::string, TRunningInfo>(function, info));
      }

      // Complete call graph
      if (fParent) {
         // We're not a level 0
         assert(fLevel > 0);

         // Only insert if not recursive call
         if (function != fParent->fFunction) {
            // Check whether we are already in
            TCallInfo * child = 0;
            if (fCalls.size() > fLevel) {
               child = fCalls[fLevel];
            }

            // Browse every possible entry
            if (child) {
               for (; child != 0; child = child->fNeighbor) {
                  if (child->fFunction == function) {
                     break;
                  }
               }
            }

            // Now, we have a room for insertion
            if (child == 0) {
               child = new TCallInfo(fParent, 0, function);
               if (fCalls.size() > fLevel) {
                  TCallInfo * same = fCalls[fLevel];
                  child->fNeighbor = same->fNeighbor;
                  same->fNeighbor = child;
               } else {
                  fCalls.insert(fCalls.end(), child);
               }

               // Ensure parent has child
               fParent->fHasChild = true;
            }

            // In any case, jump level
            ++fLevel;
            // Switch parent
            fParent = child;
         }
      } else {
         // If no parent -> level == 0
         assert(fLevel == 0);
         // Also means no child
         assert(fCalls.size() == 0);

         fParent = new TCallInfo(0, 0, function);
         fCalls.insert(fCalls.end(), fParent);
         // Jump level
         ++fLevel;
      }
   }

   advice execution(functions()) : after() {
      TRunningInfo info;
      clock_t now = clock();
      std::string function = JoinPoint::signature();
      std::map<std::string, TRunningInfo>::iterator desc = fCurrent.find(function);

      assert(desc != fCurrent.end());

      --(desc->second.fReferenceCount);
      info = desc->second;

      // Are we done?
      if (info.fReferenceCount == 0) {
         std::map<std::string, TTotalInfo>::iterator tot = fTotal.find(function);

         if (tot == fTotal.end()) {
            TTotalInfo total(now - info.fStartTicks, info.fCalls);
            fTotal.insert(std::pair<std::string, TTotalInfo>(function, total));
         } else {
            tot->second.fTotalTicks += (now - info.fStartTicks);
            tot->second.fCalls += info.fCalls;
         }

         // Not running any more
         fCurrent.erase(desc);
         // Decrease level
         --fLevel;
         // Change parent
         fParent = fParent->fParent;
      }
   }

   advice execution(mainargs()) : before() {
      int * argc = (int *)tjp->arg(0);
      char *** argv = (char ***)tjp->arg(1);

      // Save call values
      fOldArgc = *argc;
      fOldArgv = *argv;

      // Reset args
      *argv = (char **)operator new(fOldArgc * sizeof(void *));
      fNewArgv = *argv;

      for (int i = 0, pos = 0; i < fOldArgc; ++i) {
         // Check for our args
         if (strncmp(fOldArgv[i], "--acprof-out=", 13)) {
            if (strncmp(fOldArgv[i] + 13, "callgrind", 9)) {
               std::cout << "Will use callgrind format output" << std::endl;
               fFormat = kCallgrind;
            }
            --(*argc);
         } else {
            // Only pass args that aren't ours to the application
            (*argv)[pos] = fOldArgv[i];
            ++pos;
         }
      }
   }

   advice execution(mainargs()) : after() {
      int * argc = (int *)tjp->arg(0);
      char *** argv = (char ***)tjp->arg(1);

      // Restore values
      *argc = fOldArgc;
      *argv = fOldArgv;

      // Release memory
      delete fNewArgv;
   }

   TProfiler() {
      fLevel = 0;
      fParent = 0;
      fFormat = kStdOut;
   }

   ~TProfiler() {
      assert(fCurrent.empty());

      std::cout << std::endl;

      // Display data at the end
      for (std::map<std::string, TTotalInfo>::const_iterator tot = fTotal.begin();
           tot != fTotal.end(); ++tot) {
         double totalTime = ((double)tot->second.fTotalTicks)/CLOCKS_PER_SEC;
         std::cout << "Function: " << tot->first.c_str() << ", calls: " << tot->second.fCalls;
         std::cout << ", total ticks: " << tot->second.fTotalTicks << ", total time: " << totalTime << "s" << std::endl;
      }

      std::cout << std::endl;

      // Display graphs at the end
      assert(fLevel == 0 && !fCalls.empty());
      for (int level = fCalls.size() - 1; level >= 0; --level) {
         TCallInfo * child = fCalls[level];
         while (child != 0) {
            // No child -> display and head back
            if (!child->fHasChild) {
               TCallInfo * parent = child;
               while (parent != 0) {
                  std::cout << parent->fFunction;

                  parent = parent->fParent;
                  if (parent != 0) {
                     std::cout << " <- ";
                  } else {
                     std::cout << std::endl;
                  }
               }
            }

            // Release and go to the next
            TCallInfo * next = child->fNeighbor;
            delete child;
            child = next;
         }
      }
   }

private:
   bool strncmp(const char * str1, const char * str2, size_t num) {
      size_t i = 0;
      while (i < num) {
         if (!*str1 || !*str2) {
            return false;
         }
         if (*str1 != *str2) {
            return false;
         }
         ++i;
         ++str1;
         ++str2;
      }
      return true;
   }

   std::map<std::string, TRunningInfo> fCurrent;
   std::map<std::string, TTotalInfo> fTotal;
   std::vector<TCallInfo *> fCalls;
   unsigned int fLevel;
   TCallInfo * fParent;
   int fOldArgc;
   char ** fOldArgv;
   char ** fNewArgv;
   EOutput fFormat;
};

#endif
