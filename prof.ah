#ifndef __PROF_AH__
#define __PROF_AH__

#include <set>
#include <new>
#include <map>
#include <vector>
#include <ctime>
#include <string>
#include <cstring>
#include <sstream>
#include <fstream>
#include <unistd.h>
#include <iostream>
#include <sys/types.h>

struct TTotalInfo {
   unsigned long fTotalTicks;
   unsigned long fCalls;
   std::string fFile;
   int fLine;
   TTotalInfo(unsigned long totalTicks, unsigned long calls, const std::string & file, int line) : fTotalTicks(totalTicks), fCalls(calls), fFile(file), fLine(line) { };
};

struct TCallInfo {
   TCallInfo * fParent;
   TCallInfo * fNeighbor;
   std::string fFunction;
   std::string fFile;
   int fLine;
   unsigned long fCalls;
   unsigned long fTotalTicks;
   clock_t fStartTicks;
   unsigned long fReferenceCount;
   std::set<TCallInfo *> fChildren;
   TCallInfo(TCallInfo * parent, TCallInfo * neighbor, const std::string & function, const std::string & file, int line, clock_t startTicks) :
      fParent(parent), fNeighbor(neighbor), fFunction(function), fFile(file), fLine(line), fCalls(1), fTotalTicks(0), fStartTicks(startTicks),
      fReferenceCount(1) {};
};

enum EOutput {
   kStdOut,
   kCallgrind,
   kOutputMax
};

#define TProfilerAssert(e) if (!(e)) InternalAssert(__FILE__, __LINE__, __FUNCTION__, #e)

aspect TProfiler {
   pointcut functions() = "% ...::%(...)";
   pointcut mainargs() = "% main(int, char**)";
   pointcut profiler() = "% TProfiler::%(...)";

   advice execution(functions() && !profiler()) : before() {
      const clock_t now = clock();
      const int line = JoinPoint::line();
      const std::string file = JoinPoint::filename();
      const std::string function = JoinPoint::signature();

      // Complete call graph
      if (fParent) {
         // We're not a level 0
         TProfilerAssert(fLevel > 0);

         // Only insert if not recursive call
         if (function != fParent->fFunction) {
            // Check whether we are already in
            TCallInfo * child = 0;
            if (fCalls.size() > fLevel) {
               child = fCalls[fLevel];
            }

            // Browse every possible entry
            if (child) {
               for (; child != 0; child = child->fNeighbor) {
                  // Check if we already had the same function in the same execution path
                  if (child->fFunction == function && child->fParent == fParent) {
                     TProfilerAssert(child->fStartTicks == -1);
                     // Increase number of calls
                     ++child->fCalls;
                     child->fStartTicks = now;
                     ++child->fReferenceCount;
                     // We are a child
                     fParent->fChildren.insert(child);
                     break;
                  }
               }
            }

            // Now, we have a room for insertion
            if (child == 0) {
               child = new TCallInfo(fParent, 0, function, file, line, now);
               if (fCalls.size() > fLevel) {
                  TCallInfo * same = fCalls[fLevel];
                  child->fNeighbor = same->fNeighbor;
                  same->fNeighbor = child;
               } else {
                  fCalls.insert(fCalls.end(), child);
               }

               // Ensure parent has child
               fParent->fChildren.insert(child);
            }

            // In any case, jump level
            ++fLevel;
            // Switch parent
            fParent = child;
         } else {
            // Increase number of calls
            ++fParent->fCalls;
            // Increment reference count
            ++fParent->fReferenceCount;
         }
      } else {
         // If no parent -> level == 0
         TProfilerAssert(fLevel == 0);
         // Also means no child
         TProfilerAssert(fCalls.size() == 0);

         fParent = new TCallInfo(0, 0, function, file, line, now);
         fCalls.insert(fCalls.end(), fParent);
         // Jump level
         ++fLevel;
      }
   }

   advice execution(functions() && !profiler()) : after() {
      clock_t now = clock();
      std::string function = JoinPoint::signature();

      TProfilerAssert(fParent != 0);
      TProfilerAssert(fParent->fStartTicks != -1);
      TProfilerAssert(fParent->fReferenceCount > 0);

      --fParent->fReferenceCount;

      // Are we done?
      if (fParent->fReferenceCount == 0) {
         TProfilerAssert(now >= fParent->fStartTicks);

         fParent->fTotalTicks += (now - fParent->fStartTicks);
         fParent->fStartTicks = -1;

         // Decrease level
         --fLevel;
         // Change parent
         fParent = fParent->fParent;
      }
   }

   advice execution(mainargs()) : before() {
      int * argc = (int *)tjp->arg(0);
      char *** argv = (char ***)tjp->arg(1);

      TProfilerAssert(argc != 0);
      TProfilerAssert(argv != 0);

      // Save call values
      fOldArgc = *argc;
      fOldArgv = *argv;

      // Reset args
      *argv = (char **)operator new(fOldArgc * sizeof(void *));
      fNewArgv = *argv;

      int pos = 0;
      for (int i = 0; i < fOldArgc; ++i) {
         // Check for our args
         if (strncmp(fOldArgv[i], "--acprof-out=", 13) == 0) {
            if (strncmp(fOldArgv[i] + 13, "callgrind", 9) == 0) {
               std::cout << "Will use callgrind format output" << std::endl;
               fFormat = kCallgrind;
            }
            --(*argc);
         } else {
            // Only pass args that aren't ours to the application
            (*argv)[pos] = fOldArgv[i];
            ++pos;
         }
      }

      // Zero the rest
      for (; pos < fOldArgc; ++pos) {
         (*argv)[pos] = 0;
      }
   }

   advice execution(mainargs()) : after() {
      int * argc = (int *)tjp->arg(0);
      char *** argv = (char ***)tjp->arg(1);

      TProfilerAssert(argc != 0);
      TProfilerAssert(argv != 0);

      // Restore values
      *argc = fOldArgc;
      *argv = fOldArgv;
   }

   TProfiler() {
      fLevel = 0;
      fParent = 0;
      fFormat = kStdOut;
   }

   ~TProfiler() {
      TProfilerAssert(fLevel == 0);
      TProfilerAssert(!fCalls.empty());

      if (fFormat == kStdOut) {
         std::cout << std::endl;

         std::map<std::string, TTotalInfo> total;

         // Display graphs at the end
         for (int level = fCalls.size() - 1; level >= 0; --level) {
            TCallInfo * child = fCalls[level];
            while (child != 0) {
               // No child -> display and head back
               if (child->fChildren.empty()) {
                  TCallInfo * parent = child;
                  while (parent != 0) {
                     std::cout << parent->fFunction;

                     parent = parent->fParent;
                     if (parent != 0) {
                        std::cout << " <- ";
                     } else {
                        std::cout << std::endl;
                     }
                  }
               }

               // Compute total resources
               std::map<std::string, TTotalInfo>::iterator tot = total.find(child->fFunction);
               if (tot != total.end()) {
                  tot->second.fCalls += child->fCalls;
                  tot->second.fTotalTicks += child->fTotalTicks;
               } else {
                  TTotalInfo tot(child->fTotalTicks, child->fCalls, child->fFile, child->fLine);
                  total.insert(std::pair<std::string, TTotalInfo>(child->fFunction, tot));
               }

               // Release and go to the next
               TCallInfo * next = child->fNeighbor;
               delete child;
               child = next;
            }
         }

         std::cout << std::endl;

         // Display data at the end
         for (std::map<std::string, TTotalInfo>::const_iterator tot = total.begin();
              tot != total.end(); ++tot) {
            double totalTime = ((double)tot->second.fTotalTicks)/CLOCKS_PER_SEC;
            std::cout << "Function: " << tot->first.c_str() << " (" << tot->second.fFile << ":" << tot->second.fLine << "), calls: " << tot->second.fCalls;
            std::cout << ", total ticks: " << tot->second.fTotalTicks << ", total time: " << totalTime << "s" << std::endl;
         }

      }  else {
         std::ofstream outFile;
         std::stringstream file;
         int pid = getpid();

         // Get output file name
         file << "callgrind.out." << pid;
         outFile.open(file.str().c_str());

         // Put PID
         outFile << "pid: " << pid << std::endl;

         // Get command line
         outFile << "cmd:";
         for (int i = 0; i < fOldArgc; ++i) {
            // If zero => we removed args, there's nothing after
            if (fNewArgv[i] == 0) {
               break;
            }
            outFile << " " << fNewArgv[i];
         }
         outFile << std::endl;

         outFile << "events: ticks time" << std::endl;

         // Output summary (ie, total events)
         TCallInfo * child = fCalls[0];
         outFile << "summary: " << child->fTotalTicks << std::endl;

         std::string lastFile = "";
         for (unsigned int level = 0; level < fCalls.size(); level++) {
            child = fCalls[level];
            for (; child != 0; child = child->fNeighbor) {
               outFile << std::endl;
               // First display data about the calling function
               if (child->fFile != lastFile) {
                  outFile << "fl=" << child->fFile << std::endl;
                  lastFile = child->fFile;
               }
               outFile << "fn=" << child->fFunction << std::endl;
               double totalTime = ((double)child->fTotalTicks)/CLOCKS_PER_SEC;
               outFile << child->fLine << " " << child->fTotalTicks << " " << totalTime << std::endl;

               // Then display each of the callee
               for (std::set<TCallInfo *>::const_iterator it = child->fChildren.begin(); it != child->fChildren.end(); ++it) {
                  TCallInfo * callee = (*it);
                  if (callee->fFile != lastFile) {
                     outFile << "cfl=" << callee->fFile << std::endl;
                     lastFile = callee->fFile;
                  }
                  outFile << "cfn=" << callee->fFunction << std::endl;
                  outFile << "calls=" << callee->fCalls << std::endl;
                  totalTime = ((double)callee->fTotalTicks)/CLOCKS_PER_SEC;
                  outFile << callee->fLine << " " << callee->fTotalTicks << " " << totalTime << std::endl;
               }
            }
         }

         // Release memory
         for (int level = fCalls.size() - 1; level >= 0; --level) {
            // Get call stack
            child = fCalls[level];
            while (child != 0) {	
               // Release and go to the next
               TCallInfo * next = child->fNeighbor;
               delete child;
               child = next;
            }
         }

         outFile.close();
      }

      delete fNewArgv;
   }

private:
   void InternalAssert(const char * file, unsigned int line, const char * function, const char * expression) {
      std::cerr << file << ":" << line << ": " << function << ": Assertion `" << expression << "' failed." << std::endl;
      std::cerr << "Current level: " << fLevel << std::endl;
      std::cerr << "Current parent: " << fParent << std::endl;
      std::cerr << "Call tree size: " << fCalls.size() << std::endl;
      for (unsigned int i = 0; i < fCalls.size(); ++i) {
         TCallInfo * child = fCalls[i];
         std::cerr << "Level " << i << std::endl;
         for (; child != 0; child = child->fNeighbor) {
            std::cerr << "\tChild: " << child << std::endl;
            std::cerr << "\tFunction: " << child->fFunction << std::endl;
            std::cerr << "\tCalls: " << child->fCalls << std::endl;
            std::cerr << "\tTotalTicks: " << child->fTotalTicks << std::endl;
            std::cerr << "\tStartTicks: " << child->fStartTicks << std::endl;
            std::cerr << "\tReferenceCount: " << child->fReferenceCount << std::endl;
            for (std::set<TCallInfo *>::const_iterator it = child->fChildren.begin(); it != child->fChildren.end(); ++it) {
               TCallInfo * callee = (*it);
               std::cerr << "\t\tCallee: " << callee << std::endl;
            }
         }
      }
      throw;
   }

   std::vector<TCallInfo *> fCalls;
   unsigned int fLevel;
   TCallInfo * fParent;
   int fOldArgc;
   char ** fOldArgv;
   char ** fNewArgv;
   EOutput fFormat;
};

#endif
